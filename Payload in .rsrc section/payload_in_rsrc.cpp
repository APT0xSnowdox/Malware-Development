//create a resource file and name it as resource-type -> RCDATA after importing the payload in .bin format
/*
first line should be like in resource.h file

#define IDR_RCDATA1			101



Once compiled, the payload will now be stored in the .rsrc section, but it cannot be accessed directly. Instead, several WinAPIs must be used to access it.

FindResourceW - Get the location of the specified data stored in the resource section of a special ID passed in (this is defined in the header file)
LoadResource - Retrieves a HGLOBAL handle of the resource data. This handle can be used to obtain the base address of the specified resource in memory.
LockResource - Obtain a pointer to the specified data in the resource section from its handle.
SizeofResource - Get the size of the specified data in the resource section.

*/

#include <windows.h>
#include <stdio.h>
#include "resource.h"

int main() {
	//initiate variables
	HRSRC hRsrc = NULL;
	HGLOBAL hGlobal = NULL;
	PVOID pPayloadAddress = NULL;
	SIZE_T sPayloadSize = NULL;

	//Get the location of the data stored in the .rsrc by its ID *IDR_RCDATA1*
	hRsrc = FindResourceW(NULL, MAKEINTRESOURCEW(IDR_RCDATA1), RT_RCDATA);
	if (hRsrc == NULL) {
		printf("FindResource Failed with error: %d\n", GetLastError());
		return -1;
	}
	// Get HGLOBAL, or the handle of the specified resource data since its required to call LockResource later
	hGlobal = LoadResource(NULL, hRsrc);
	if (hGlobal == NULL) {
		printf("Load Resource Failed with Error: %d\n", GetLastError());
		return -1;
	}

	//Get the address of our payload in .rsrc section
	pPayloadAddress = LockResource(hGlobal);
	if (pPayloadAddress == NULL) {
		printf("LockResource Failed with error: %d\n", GetLastError());
		return -1;
	}

	//Get the size of payload in .rsrc section
	sPayloadSize = SizeofResource(NULL, hRsrc);
	if (sPayloadSize == NULL) {
		printf("sizeofresource Failed: %d\n", GetLastError());
		return -1;
	}

	//updating .rsrc payload
	/*
	Since the payload can't be edited directly from within the resource section, it must be moved to a temporary buffer. 
	To do so, memory is allocated the size of the payload using HeapAlloc and then the payload is moved from the resource section to the temporary buffer using memcpy.
	*/
	PVOID pTmpBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sPayloadSize);
	if (pTmpBuffer != NULL) {
		memcpy(pTmpBuffer, pPayloadAddress, sPayloadSize);
	}

	/*
	Since pTmpBuffer now points to a writable memory region that is holding the payload, it's possible to decrypt
	the payload or perform any updates to it.
	
	*/

	//printing pointer and size to the screen
	printf("pPayloadAddress var: 0x%p\n", pPayloadAddress);
	printf("sPayloadSize var: 0x%p\n", sPayloadSize);
	printf("pTmpBuffer var: 0x%p\n", pTmpBuffer);
	printf("Press Enter to quit...");
	getchar();
	return 0;

	/*
	After compiling and running the code above, the payload address along with its size will be printed onto the screen. It is important to note that this address is in the .rsrc section,
	which is read-only memory, and any attempts to change or edit data within it will cause an access violation error. To edit the payload, a buffer must be allocated with the same size as the payload and copied over. This new buffer is where changes, 
	such as decrypting the payload, can be made.
	
	*/
}